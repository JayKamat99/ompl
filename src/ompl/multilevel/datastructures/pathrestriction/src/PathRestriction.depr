
    //Configuration *xLast = xStart;

    //base::SpaceInformationPtr bundle = bundleSpaceGraph_->getBundle();
    //base::SpaceInformationPtr base = bundleSpaceGraph_->getBase();
    //base::SpaceInformationPtr fiber = bundleSpaceGraph_->getFiber();

    //for (unsigned int k = 1; k < section.size(); k++)
    //{
    //    if (bundle->checkMotion(section.at(k - 1), section.at(k), lastValid_))
    //    {
    //        if (k < section.size() - 1)
    //        {
    //            xLast = addFeasibleSegment(xLast, section.at(k));
    //        }
    //        else
    //        {
    //          //TODO: what if xLast does NOT equal section.at(k-1)?
    //            addFeasibleGoalSegment(xLast, xGoal);
    //            OMPL_DEBUG("Found feasible path section");
    //            bundle->freeStates(section);

    //            return true;
    //        }
    //    }
    //    else
    //    {
    //        //############################################################################
    //        // Get Last valid
    //        //############################################################################
    //        Configuration *xLastValid{nullptr};
    //        // std::cout << "Stopped at last valid location: " << 
    //        //   lastValid_.second << "with k=" << k <<"/"<<section.size()<< std::endl;
    //        if (lastValid_.second > 0)
    //        {
    //            // add last valid into the bundle graph
    //            xLastValid = new Configuration(bundle, lastValid_.first);
    //            bundleSpaceGraph_->addConfiguration(xLastValid);
    //            bundleSpaceGraph_->addBundleEdge(xLast, xLastValid);
    //            xLast = xLastValid;
    //        }
    //        else
    //        {
    //            xLastValid = xLast;
    //        }

    //        //############################################################################
    //        // Get length until last Valid
    //        //############################################################################
    //        double locationOnBasePath = 0.0;
    //        unsigned int stopK = k;
    //        if(interpolateFiberFirst)
    //        {
    //          //NOTE: first segment of section does not exist on base path
    //            stopK -= 1;

    //        }
    //        if(stopK < 1)
    //        {
    //          //no movement on base path
    //          locationOnBasePath = 0;
    //        }else{
    //            for (unsigned int j = 1; j < stopK; j++)
    //            {
    //                double dj = bundleSpaceGraph_->getBase()->distance(basePath.at(j - 1), basePath.at(j));
    //                locationOnBasePath += dj;
    //            }

    //            if (stopK < basePath.size())
    //            {
    //                double dLastSegment = 
    //                  bundleSpaceGraph_->getBase()->distance( 
    //                      basePath.at(stopK - 1), 
    //                      basePath.at(stopK));

    //                double dLocationLastSegment = lastValid_.second * dLastSegment;

    //                //make one more step into the constraint
    //                if( dLocationLastSegment + validSegmentLength_ < dLastSegment)
    //                {
    //                    dLocationLastSegment += validSegmentLength_;
    //                }
    //                locationOnBasePath += dLocationLastSegment;
    //            }
    //        }

    //        static_cast<BundleSpaceGraph *>(bundleSpaceGraph_->getParent())
    //            ->getGraphSampler()
    //            ->setPathBiasStartSegment(locationOnBasePath + startLength);

    //        if (depth + 1 >= PATH_SECTION_L1UTURN_MAX_DEPTH)
    //        {
    //            return false;
    //        }

    //        //############################################################################
    //        // Clip base path segment to last valid
    //        //############################################################################

    //        bundle->projectBase(xLastValid->state, xBaseTmp_)

    //        int lastCtr = section->getLastValidBasePathIndex();

    //        std::vector<base::State *> basePathSegment = 
    //        {basePath.begin() + lastCtr + 1, basePath.end()};

    //        basePathSegment.insert(basePathSegment.begin(), xBaseTmp_);

    //        //double dist = 0;
    //        //if(wriggleFree(lastValid_.first, section.at(stopK+1), xBundleTmp_, dist))
    //        //{
    //        //    std::cout << "Successful wriggle step" << std::endl;
    //        //    //If wriggle succeeds, we are likely not in a crevice-like
    //        //    //structure in cspace, but we can continue
    //        //    Configuration *xContinue = new Configuration(bundle, xBundleTmp_);
    //        //    bundleSpaceGraph_->addConfiguration(xContinue);
    //        //    bundleSpaceGraph_->addBundleEdge(xLastValid, xContinue);

    //        //    bool feasibleSection = checkSectionL1BacktrackRecursive(
    //        //        xContinue, xGoal, basePathSegment, 
    //        //        false, depth + 1, locationOnBasePath + dist);

    //        //    bundle->freeStates(section);

    //        //    if (feasibleSection)
    //        //    {
    //        //        return true;
    //        //    }
    //        //    return false;
    //        //}


    //        break;
    //    }
    //}
    //bundle->freeStates(section);
    //return false;

//const unsigned int PATH_SECTION_TREE_MAX_DEPTH = 3;
//const unsigned int PATH_SECTION_TREE_MAX_BRANCHING = 10;

//bool PathRestriction::checkSectionL1Recursive(
//    Configuration *const xStart, Configuration *const xGoal, const std::vector<base::State *> basePath,
//    bool interpolateFiberFirst, unsigned int depth, double startLength)
//{
//    bundleSpaceGraph_->projectFiber(xStart->state, xFiberStart_);
//    bundleSpaceGraph_->projectFiber(xGoal->state, xFiberGoal_);

//    base::SpaceInformationPtr bundle = bundle;

//    std::vector<base::State *> section;
//    if (interpolateFiberFirst)
//    {
//        section = interpolateSectionL1FF(xFiberStart_, xFiberGoal_, basePath);
//    }
//    else
//    {
//        section = interpolateSectionL1FL(xFiberStart_, xFiberGoal_, basePath);
//    }

//    Configuration *xLast = xStart;

//    for (unsigned int k = 1; k < section.size(); k++)
//    {
//        if (bundle->checkMotion(section.at(k - 1), section.at(k), lastValid_))
//        {
//            if (k < section.size() - 1)
//            {
//                xLast = addFeasibleSegment(xLast, section.at(k));
//            }
//            else
//            {
//                addFeasibleGoalSegment(xLast, xGoal);
//                OMPL_DEBUG("Found feasible path section (%d edges added)", k);
//                bundle->freeStates(section);

//                return true;
//            }
//        }
//        else
//        {
//            //############################################################################
//            // Get Last valid
//            //############################################################################
//            Configuration *xLastValid{nullptr};
//            if (lastValid_.second > 0)
//            {
//                // add last valid into the bundle graph
//                xLastValid = new Configuration(bundle, lastValid_.first);
//                bundleSpaceGraph_->addConfiguration(xLastValid);
//                bundleSpaceGraph_->addBundleEdge(xLast, xLastValid);
//                xLast = xLastValid;
//            }
//            else
//            {
//                xLastValid = xLast;
//            }

//            //############################################################################
//            // Get length until last Valid
//            //############################################################################

//            double locationOnBasePath = 0.0;
//            unsigned int stopK = k;
//            if(interpolateFiberFirst)
//            {
//                stopK -= 1;
//            }
//            for (unsigned int j = 1; j < stopK; j++)
//            {
//                double dj = bundleSpaceGraph_->getBase()->distance(basePath.at(j - 1), basePath.at(j));
//                locationOnBasePath += dj;
//            }

//            if (stopK < basePath.size())
//            {
//                locationOnBasePath +=
//                    lastValid_.second * bundleSpaceGraph_->getBase()->distance(basePath.at(stopK - 1), basePath.at(stopK));
//            }

//            static_cast<BundleSpaceGraph *>(bundleSpaceGraph_->getParent())
//                ->getGraphSampler()
//                ->setPathBiasStartSegment(locationOnBasePath + startLength);

//            if (depth + 1 >= PATH_SECTION_TREE_MAX_DEPTH)
//            {
//                bundle->freeStates(section);
//                return false;
//            }

//            //############################################################################
//            // Side step randomly and interpolate from there towards goal
//            //############################################################################
//            unsigned int lastCtr = bundleSpaceGraph_->interpolateAlongBasePath(basePath, locationOnBasePath, xBaseTmp_);

//            std::vector<base::State *> basePathSegment = {basePath.begin() + lastCtr, basePath.end()};
//            basePathSegment.insert(basePathSegment.begin(), xBaseTmp_);

//            for (unsigned int j = 0; j < PATH_SECTION_TREE_MAX_BRANCHING; j++)
//            {
//                //#############################################################
//                // find feasible sample in current fiber
//                //#############################################################
//                if (!sideStepAlongFiber(xBaseTmp_, xBundleTmp_))
//                    continue;

//                //#############################################################
//                // check that we can connect new sample with last states
//                //#############################################################
//                if (bundle->checkMotion(xLastValid->state, xBundleTmp_))
//                {
//                    Configuration *xSideStep = new Configuration(bundle, xBundleTmp_);
//                    bundleSpaceGraph_->addConfiguration(xSideStep);
//                    bundleSpaceGraph_->addBundleEdge(xLastValid, xSideStep);

//                    //#########################################################
//                    // side step was successful.
//                    // Now interpolate from there to goal
//                    //#########################################################

//                    bool feasibleSection = checkSectionL1Recursive(xSideStep, xGoal, basePathSegment,
//                                                                       !interpolateFiberFirst, depth + 1, locationOnBasePath);

//                    if (feasibleSection)
//                    {
//                        bundle->freeStates(section);
//                        return true;
//                    }
//                }
//            }

//            break;
//        }
//    }
//    bundle->freeStates(section);
//    return false;
//}

// bool PathRestriction::checkSectionL2(
//     Configuration *const xStart, Configuration *const xGoal)
// {
//     bundleSpaceGraph_->projectFiber(xStart->state, xFiberStart_);
//     bundleSpaceGraph_->projectFiber(xGoal->state, xFiberGoal_);

//     std::vector<base::State *> section = interpolateSectionL2(xFiberStart_, xFiberGoal_, basePath_);

//     Configuration *xLast = xStart;

//     base::SpaceInformationPtr bundle = bundleSpaceGraph_->getBundle();

//     bool found = false;
//     for (unsigned int k = 1; k < section.size(); k++)
//     {
//         if (bundle->checkMotion(section.at(k - 1), section.at(k), lastValid_))
//         {
//             if (k < section.size() - 1)
//             {
//                 xLast = addFeasibleSegment(xLast, section.at(k));
//             }
//             else
//             {
//                 addFeasibleGoalSegment(xLast, xGoal);
//                 OMPL_DEBUG("Found feasible path section (%d edges added)", k);
//                 found = true;
//                 break;
//             }
//         }
//         else
//         {
//             if (lastValid_.second > 0)
//             {
//                 // add last valid into the bundle graph
//                 Configuration *xk = new Configuration(bundle, lastValid_.first);
//                 bundleSpaceGraph_->addConfiguration(xk);
//                 bundleSpaceGraph_->addBundleEdge(xLast, xk);
//             }

//             double length = std::accumulate(intermediateLengthsBasePath_.begin(),
//                                             intermediateLengthsBasePath_.begin() + (k - 1), 0.0);

//             length += lastValid_.second * bundleSpaceGraph_->getBase()->distance(basePath_.at(k - 1), basePath_.at(k));

//             static_cast<BundleSpaceGraph *>(bundleSpaceGraph_->getParent())
//                 ->getGraphSampler()
//                 ->setPathBiasStartSegment(length);
//             break;
//         }
//     }
//     bundle->freeStates(section);
//     return found;
// }

    // check for quasisection computation module
    // int type = bundleSpaceGraph_->getBundle()->getStateSpace()->getType();
    // if (type == base::STATE_SPACE_DUBINS)  // || type == base::STATE_SPACE_DUBINS_AIRPLANE)
    // {
    //     // Quasisections
    //     bundleSpaceGraph_->projectFiber(xStart->state, xFiberStart_);
    //     bundleSpaceGraph_->projectFiber(xGoal->state, xFiberGoal_);
    //     std::vector<base::State *> section = interpolateSectionL2(xFiberStart_, xFiberGoal_, basePath_);

    //     Configuration *xLast = xStart;

    //     for (unsigned int k = 1; k < section.size(); k++)
    //     {
    //         if (bundleSpaceGraph_->getBundle()->checkMotion(section.at(k - 1), section.at(k), lastValid_))
    //         {
    //             if (k < section.size() - 1)
    //             {
    //                 xLast = addFeasibleSegment(xLast, section.at(k));
    //             }
    //             else
    //             {
    //                 if (xGoal->index <= 0)
    //                 {
    //                     bundleSpaceGraph_->vGoal_ = bundleSpaceGraph_->addConfiguration(xGoal);
    //                 }
    //                 addFeasibleGoalSegment(xLast, xGoal);
    //                 OMPL_DEBUG("Found feasible path section (%d edges added)", k);
    //                 return true;
    //             }
    //         }
    //         else
    //         {
    //             addFeasibleSegment(xLast, lastValid_.first);
    //             return false;
    //         }
    //     }
    //     return true;
    // }
    // else
    // {
        // bool foundFeasibleSection = checkSectionL1BacktrackRecursive(xStart, xGoal, basePath_);
        // if (!foundFeasibleSection)
        // {
        //     // Try with inverse L1
        //     foundFeasibleSection = checkSectionL1BacktrackRecursive(xStart, xGoal, basePath_, false);
        // }

        // return foundFeasibleSection;
    // }
